# Unix编程艺术读书笔记


## Unix之失

Unix 用户必须自己设置策略，非技术型的终端用户会被Unix丰富的选项和接口风格搞的晕头转向，转而选择那些能够给他们提供简介服务的操作系统。

## Unix哲学基础

1. 每个程序就做好一件事。如果有新任务，就重新开始，不要往源程序加入新功能而搞得复杂。
2.  假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要又无关的信息干扰。避免使用严格的芬兰个事和二进制输入。
3.  尽早的将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是几星期内。对拙劣的代码别犹豫，扔掉重写。
4.  优先使用工具而不是拙劣的帮助来减轻变成任务的负担。

一言蔽之：
**Keep It Simple,Stupid!**


## Unix风格元素
1. 统一性概念： 一切皆文件
2. 多任务能力: 抢先式多任务
3. 协作进程： 低价的进程生成和渐变的进程间通信
4. 内部边界： 内存管理、权限管理、设计安全性的功能代码限制在尽可能小的可信代码块上。
5. 文件的属性和结构：没有记录结构也没有文件属性（文件中有固定长度的文件描述）。
6. 二进制文件：没用二进制来存放关键数据（如用户记录）
7. 首选用户风格：CLI
8. 目标受众：写给程序员的。
9. 开发的门槛：廉价的工具和简单的接口


## 模块性：保持清晰，保持简洁
![Alt text](./1495614471464.png)

200 ~ 400之间逻辑行的代码是最佳点，

## 紧凑性
是指一个设计是否装入人脑中的特性（即能否记住所有的东西）。

## 正交性
是指任何操作无副作用，每一个动作只改变一件事，不会影响其他

## STOP原则
任何一个知识点在系统内部有一个唯一、明确、权威的表述。（即不要重复定义一个东西，无垃圾无混淆）。

## 不要重复造轮子

我觉得这是很多程序员挂在嘴边的一句话，UNIX推动了开源事业的发展，也给我们带了了很多轮子。以前在博客园看过一篇文章《到底是否应该重复造轮子》，作者最后说道“99%的人都不应该重复造轮子，只有1%的人应该去做这件事，因为只有1%甚至更少的人，造轮子造出了未来，而剩下的，都成为了这少数人的绿叶，衬托着他们的光芒，对于剩下的这批人来说，这些轮子造的意义并不大，至少对他们自己来说，花费的时间与得到的成长不成正比。”。我个人的观点认为，作为新一代的程序员，我们踩在无数巨人的肩膀上，我们的确不应该去重复造轮子，但我们需要知道怎么去造轮子，懂得这个轮子背后的实现原理，这样你在遇到新问题的适合至少知道怎样去解决。而且对于新手程序员来说，“只管使用、不管原理”这样的想法也不利于自身的成长。其次，我们也要选择一个合适的轮子，不然你还不如自己造一个。

## 简洁的是最好的

UNIX哲学基础中有一条简洁原则——设计要简洁，复杂度能低则低。在UNIX系统中的工具就是最好的例子，它们只做一件事情，但通过管道将他们连在一起却能完成许多复杂的工作，当然UNIX的“文本化协议”息息相关。如果单从设计角度来说的话，简洁就是一个程序的功能要尽可能的单一，不要想着我做的这个程序能胜任所有工作，到头来才发现连一个简单的工作都完成不了，还经常出现BUG。另外，程序员在技术上的虚荣心也是导致程序复杂度无限提升的原因，为了展现自己的技术实力，他们经常使用复杂的算法去完成简单的功能，最后出了问题连自己也解决不了。这种本可以避免的错误就是在浪费我们的时间，我们应该把时间投入到新问题中，而不是为这样的旧错误擦屁股，所以，为了世界和平（程序员会做出什么事，连自己都不知道）请降低你的代码复杂度，记住难于理解、维护和扩展的代码就是复杂的代码。计算机编程的本质就是控制复杂度, Kepp it sample，stupid！

## 过早的局部优化实际上会妨碍全局优化，先制作原型，再精雕细琢，优化之前先确保能用

我很赞同这句话所表达的观点。优化是一个长期的过程，而且在你的程序都不能正常运行的情况下就去进行局部优化，除非你有足够的信息和技术，否则你就是在作死，因为你永远不知道你的优化会导致什么新的问题，还没学会走你就想跑了~



“极限编程”宗师Kent Beck说过“先求运行，再求正确，最后求快”，在电脑硬件极速膨胀的今天，对于大多数程序员（还有少数人属于特殊领域）来说真的没有必要为了节省一点运行时间去进行过早的优化，当你的程序能正确运行的时候，你自然会发现哪些地方需要进行优化。上周用Nodejs重写Global Configuration API的时候就运用了一下这个思想，我认为这样做的好处在于你的优化更具有针对性，而不是自以为这个地方就该优化一下。即便是在过程中产生了新的BUG，我们也能更快、更好的解决掉，同时也印证了另外一个观点——最好的优化工具就是Delete键。

## 模块不宜过小，也不能过大

要编制复杂软件而又不至于一败涂地的唯一的方法就是降低其整体复杂度——用清晰的接口把若干个简单的模块组合成一个复杂的软件。如此一来，多数问题就只会局限于某个局部，那么还有希望对局部进行改进而不至于牵动全身。模块作为其中重要的组成部分，扮演者重用的角色，模块过大或过小都会产生更多的BUG，那么怎样才能算是一个适合的模块呢？模块划分常常是程序设计中最难的一部分，可以把模块看成是一个小程序，就像UNIX系统中的小工具一样，他们的职责应该简单、单一，各个模块之间通过接口相互协作，我觉得一个模块可以被替换而不会影响整体的运行就是最合适的。当然，具体的划分还是需要根据具体的情况作出调整。

这里我想到另外一个观点——宽进严出，我觉得这同样也使用于模块设计，因为你不能保证其他模块或者用户的输入是严格按照你的要求来做的，但是你应该保证你的输出是严格一致的，不会经常发生变化（这里的变化通常是指数据结构的改变），这样才能与其他模块更好的协作。

## 代码是活代码、睡代码还是死代码？

“活代码”是指在你的周围存在一个非常活跃的开发社区，“睡代码”之所以睡着，经常是因为对作者而言，维护代码的痛苦超过了代码本身的效用，而“死代码”则是睡得太久，重新实现一段等价的代码更容易。

## 提供机制，而非策略

个人理解的就是机制是做什么，策略是怎么做，这样的好处就是使用“机制”的用户可以根据自己的需要使用自己的“策略”来实现其中的细节，而且这样很容易更换“策略”而不会影响“机制”。其实这就是接口的工作，以前在学校学习三层架构的时候每一层都有一个接口层，比如，数据访问层有一个接口层定制了需要提供的功能（做什么），而具体的实现可以根据不同的场景而改变，SQL Server可以用SQL Server的访问层、Oracle可以用Oracle的访问层（怎么做），你底层的更换并不会影响到上一层。

## 总结

最初以为书本中会有许多示例代码，到头来才发现除了文字还是文字，阅读过程中难免会感觉枯燥，就记得了一件事：那就是代码要简洁，一个代码做一件事，小而美。